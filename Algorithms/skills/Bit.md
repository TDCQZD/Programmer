# Bit 位运算

## 什么是位运算
程序中的所有数在计算机内存中都是以二进制的形式储存的。**位运算说穿了，就是直接对整数在内存中的二进制进行操作。**比如，`and`是一个逻辑运算符，但整数与整数之间也可以进行`and`运算。
示例：6 的 二进制110，11的二进制1011，6 and 11 结构就是2，它是二进制对应位进行逻辑运算的结果。(0:False,1:True,空位都当0处理)
```
110 AND 1011 --> 0010(b) --> 2(d)
```
由于位运算直接对内存数据进行操作，**不需要转成十进制，因此处理速度非常快。**

## 位运算

![位运算](../images/Bit.png)

### XOR - 异或
> 异或：相同时为0，不同为1.
异或操作的一些特点：
```
x ^ 0 = x
x ^ 1s(全部二进制位都为1) = ~x // ls = ~0
x ^ (~x) = 1s
x ^ x = 0 //
a ^ b = c => a ^ c = b, b ^ c = a //swap
a ^ b ^ c = a ^ (b ^ c) = (a ^ b) ^ c // associative
```

## 编程常用的位运算操作
1. `X & 1 == 1 OR == 0` => 判断奇偶（x % 2 == 1）
2. `X = X & (X-1)` => 清零最低位的1
3. `X & -X `=> 得到最低位的1
4. `X & ~X` => 0

**更为复杂的位运算操作：**

1. 将 `x` 最右边的 `n` 为 清零 :    `x & (~0 << n) `
2. 获取 `x` 的第 `n` 位值（0或1）:  (x >> n) & 1 
3. 获取 `x` 的第 `n` 位幂值 :   x &(1 << (n - 1))
4. 仅将第 `n` 位置为1 : x | (1 << n)
5. 仅将第 `n` 位置为0 : x & (~(1 << n))
6. 将 `x` 最高位至第 `n` 位(含)清零 : x & ((1 << n) - 1)
7. 将第 `x` 位至第0位(含)清零 : x &(~((1 << (n + 1)) - 1))

## 案例
### 1、 `n & 1` 判断奇偶数
1. 取余
```
n % 2 == 1  //奇数
```
2. 逻辑运算符
```
n & 1 == 1  //奇数
```

### 2、`n & (n - 1)` 消除数字 n 的二进制表示中的最后一个 1
```
 n & (n - 1) : (1001) & (1000) = 1000
```
**适用场景：**
1. 判断一个正整数 n 是否为 2 的幂次方
```
(n & (n - 1)) == 0 //如果不为 0，则代表 n 不是 2 的幂次方
```
2. 判断 正整数 n 的二进制表示中有多少个 1
```
        int count = 0;
        int k = 1;
        while (n != 0) {
            count++;
            n = (n - 1) & n;//执行 n & (n - 1)，每执行一次就可以消去一个 1，当 n 为 0 时，计算总共执行了多少次即可
        }
```
3. 利用或操作 | 和空格将英文字符转换为小写
```
('a' | ' ') = 'a'
('A' | ' ') = 'a'
```
4. 利用与操作 & 和下划线将英文字符转换为大写
```
('b' & '_') = 'B'
('B' & '_') = 'B'
```
5. 利用异或操作 ^ 和空格进行英文字符大小写互换
```
('d' ^ ' ') = 'D'
('D' ^ ' ') = 'd'
```
6. 判断两个数是否异号
```
int x = -1, y = 2;
bool f = ((x ^ y) < 0); // true

int x = 3, y = 2;
bool f = ((x ^ y) < 0); // false
```
> 这个技巧还是很实用的，利用的是补码编码的符号位。如果不用位运算来判断是否异号，需要使用 if else 分支，还挺麻烦的。读者可能想利用乘积或者商来判断两个数是否异号，但是这种处理方式可能造成溢出，从而出现错误。