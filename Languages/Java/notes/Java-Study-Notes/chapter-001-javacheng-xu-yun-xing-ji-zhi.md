# **一、高级语言的运行机制**

计算机高级编程语言按其程序的执行方式可分为编译型语言和解释型语言。

编译型语言足指使专门的编译器，针对特定平台（操作系统）将某种高级语言源代码一次性“翻译”成 可被该平台硬件执行的机器码（包括机器指令和操作数），并包装成该平台所能识别的可执行性程序的格式，这个转换过程称为编译（ Compile \)。编译生成的可执行性程序可以脱离开发环境，在特定的 平台上独立运行。

有些程序编译结朿后，还可能需要对其他编译好的 目标代码进行链接，即组装两个以上的 目 标代码模块生成最终的可执行性程序，通过这种方式实现低层次的代码 复用。

因为编译型语言是一次性地编译成机器码，所以可以脱离开发环境独立运行，而且通常运行效率较高；但因为编译型语言的程序被编译成特走平台上的机器码，因此编译生成的可执行性程序通常无法移动到其他平台上运行；如果需要移植，则必须将源代码复制到特定平台上，针对特走平台进行修改，至少也需要采用特定平台上的编译器重新编译。

现有的 C 、 C ++、 Objective - C 、 Pascal 等高级语言都属于编译型语言。

解释型语言足指使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行的语言。解型语言通常不会进行整体性的编译和链接处理，解释型语言相当于把编译型语言屮的编译和解释过程混合到一起 同 时完成。

可以认为：每次执行解释切语言的程序都需要进行一次编译，因此解释型语言的程序运行效率通常较低，而且不能脱离解释器独立运行。但解释型语言冇一个优势：跨平台比较容易，只需提供特定平台的解释器即可，每个特定平台上的解释器负责将源程序解释成特定平台的机器指令即可。解释型语言可  
以方便地实现源程序级的移植，但这是以牺种程序执行效率为代价的。

现有的Ruby、Python 等高级语言都属于编译型语言。

# 二、Java语言运行机制

Java 语言是一种特殊的高级语言，它既具有解释型语言的特征，也具有编译型语言的特征，因为Java 程序要经过先编译，后解释两个步骤。

## 1、Java是编译型和解释型语言的结合体

①首先采用通用的java编译器将java源程序编译成为与平台无关的字节码文件（class文件）

②然后由java虚拟机（JVM）对字节码文件解释执行。

![](/assets/java程序执行步骤.jpg)

注意：java字节码具有平台无关性、可以在各种不同系统平台中运行，但是需要有不同版本的java虚拟机，不同系统平台的java运行环境其java虚拟机是不一样的。

## 2、JVM\(Java Virtual Machine Java虚拟机\)

（1）JVM是Java字节码执行的引擎，为java程序的执行提供必要的支持，还能优化java字节码，使之转换成效率更高的机器指令。程序员编写的程序最终都要在JVM上执行，JVM中类的装载是由类加载器（ClassLoader）和它的子类来实现的。

（2）ClassLoader是java运行时一个重要的系统组件，负责在运行时查找和装入类文件的类。

（3）JVM屏蔽了与具体操作系统平台相关的信息，从而实现了java程序只需生成在JVM上运行的字节码文件（class文件），就可以在多种平台上不加修改地运行。不同平台对应着不同的JVM，在执行字节码时，JVM负责将每一条要执行的字节码送给解释器，解释器再将其翻译成特定平台环境的机器指令并执行。java语言最重要的特点就是跨平台运行，使用JVM就是为了支持与操作系统无关，实现跨平台运行。

## 3、JRE

JRE是JavaRuntimeEnvironment，java运行时环境，它是java程序运行所必须的环境集合，主要由java虚拟机、java平台核心类和若干支持文件组成。其不包含开发工具、编译器、调试器以及其他工具。

在执行java程序的时候，操作系统会按照下面顺序寻找JRE环境。

（1）先查找当前目录下有没有JRE

（2）再查找父目录下有没有JRE

（3）接着在环境变量PATH制定的路径中查找JRE

（4）注册表查看CurrentVersion的键值指向哪个JRE

JRE自带的基础类库主要在JRE\LIB\rt.jar文件中。在程序运行时，JRE由ClassLoader\(类加载器\)负责查找和加载程序引用到的基类库和其他类库。基础类库，Classloader会自动到rt.jar的位置；其他的类库，ClassLoader在环境变量CLASSPATH制定的路径中搜索。

## 4、JDK

JDK是Java Development Kit，简称java开发工具包。

JDK是java的核心。它包括java运行环境、一堆java工具盒java基础的类库（rt.jar）。

JDK包含JRE的全部内容外，还包含开发者用以编译、调试和运行java程序的工具。

## 5、JDK、JRE、JVM之间的关系：

JDK、JRE、JVM之间是包含关系。范围由大到小依次为JDK、JRE、JVM。

# 三、垃圾回收机制

垃圾回收是Java中自动内存管理的另一种叫法。垃圾回收的目的是为程序保持尽可能多的可用堆（heap）。 JVM会删除堆上不再需要从堆引用的对象。

Java的垃圾回收是由JVM自动进行，对于程序员是不可控的。  
 System.gc\(\); Sysytem.getRuntime\(\).gc\(\);调用这两个方法并不会立即进行垃圾回收。

1、垃圾回收机制具有以下的特点：

\(1\)、 垃圾回收机制只负责回收堆内存，不会回收任何物理资源

\(2\)、程序无法精确控制垃圾回收的进行，会在合适的时候进行

\(3\)、在垃圾回收机制回收的任何对象之前，总会先调用它的finalize\(\)方法

需要强调的一点:垃圾回收回收的是无任何引用的对象占据的内存空间而不是对象本身

2、对象在内存中的状态

![](/assets/对象状态.jpg)

3、垃圾回收机制中的算法

Java并没有明确地说明JVM使用哪种垃圾回收算法，但是任何一种垃圾回收算法一般要做2件基本的事情：

（1）发现无用信息对象；

（2）回收被无用对象占用的内存空间，使该空间可被程序再次使用。

垃圾回收算法有很多种，如引用计数算法、可达性分析算法等

4、强制垃圾回收

强制系统垃圾回收有两种方式：

\(1\)、调用System类的gc\(\)静态方法：System.gc\(\)

\(2\)、调用Runtime对象的gc\(\)实例：Runtime.getRuntime\(\).gc\(\)

强调：所谓强制回收，其实也仅仅是一个建议。JVM接受这个消息后，并不是立即做垃圾回收，而只是对几个垃圾回收算法做了加权，使垃圾回收操作容易发生，或提早发生，或回收较多而已。

5、finalize方法

为什么要使用这个方法呢？这是一个默认机制，当要回收某个内存之前，通常需要调用适当的方法来清理资源，而这个方法就是finalize方法。它的原型为：protected void finalize\(\) throws Throwable。在finalize\(\)方法返回之后，对象消失，垃圾收集开始执行。原型中的throws Throwable表示它可以抛出任何类型的异常。

