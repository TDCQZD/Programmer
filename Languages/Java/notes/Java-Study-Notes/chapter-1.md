# Java 泛型

Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。

泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。

# 泛型方法

你可以写一个泛型方法，该方法在调用时可以接收不同类型的参数。根据传递给泛型方法的参数类型，编译器适当地处理每一个方法调用。

下面是定义泛型方法的规则：

* 所有泛型方法声明都有一个类型参数声明部分（由尖括号分隔），该类型参数声明部分在方法返回类型之前（在下面例子中的&lt;E&gt;）。
* 每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。
* 类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。
* 泛型方法体的声明和其他方法一样。注意类型参数只能代表引用型类型，不能是原始类型（像int,double,char的等）。

## 泛型类

泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。

和泛型方法一样，泛型类的类型参数声明部分也包含一个或多个类型参数，参数间用逗号隔开。一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。

## 泛型接口

## 类型通配符

1、类型通配符一般是使用?代替具体的类型参数。例如 **List&lt;?&gt;** 在逻辑上是**List&lt;String&gt;,List&lt;Integer&gt;** 等所有List&lt;具体类型实参&gt;的父类。

2、类型通配符上限通过形如List来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。

### 边界符 {#边界符}

### PECS原则 {#边界符}

## 类型擦除 {#类型擦除}

如果在使用泛型时没有指明数据类型，那么就会擦除泛型类型

## 一、概述

**1、为什么使用泛型？**

**Java集合的特性：**

Java 集合有个缺点——把一个对象“丢进”集合里之后，集合就会“忘记”这个对象的数据类型，  
当再次取出该对象时，该对象的编译类型就变成了  Object 类型（其运行时类型没变）。  
Java 集合之所以被设计成这样，是因为集合的设计者不知道我们会用集合来保存什么类型的对象，  
所以他们把集合设计成能保存任何类型的对象，只要求具有很好的通用性。但这样做带来如下两个问题：

* 集合对元素类型没有任何限制，这样可能引发一些问题。例如，想创建一个只能保存 Dog 对象  
  的集合，但程序也可以轻易地将 Cat 对象“丢”进去，所以可能引发异常。

* 由于把对象“丢进”集合时，集合丢失了对象的状态信息，集合只知道它盛装的是 Object ，因  
  此取出集合元素后通常还需要进行强制类型转换。这种强制类型转换既增加了编程的复杂度，  
  也可能引发 ClassCastException 异常。

2、**泛型的定义**

所谓泛型，就是允许在定义类、接口、方法时使用类型形参，这个类型形参将在声明变量、创建对

象、调用方法时动态地指定（即传入实际的类型参数，也可称为类型实参 ）。Java 5改写了集合框架中

的全部接口和类，为这些接口、类增加了泛型支持，从而可以在声明集合变量、创建集合对象时传入类

型实参，这就是在前面程序中看到的 List&lt;String&gt;和 ArrayList &lt; String &gt; 两种类型。

Java的参数化类型被称为泛型。

**参数化：**

从Java5以后，Java引入了参数化类型的概念，即允许程序在创建集合时指定集合元素的类型。

**泛型的实质：**允许在定义接口、  
类时声明类型形参，类型形参在整个接口、类体内可当成类型使用，几乎所有可使用普通类型的地方都  
可以使用这种类型形参。

3**、泛型的作用？**

对于集合来讲，在创建集合时同时指定集合元素的类型，防止引发引发 ClassCastException 异常。

4、**泛型的用法**

```
List<String> list = new ArrayList();
List<Object> l=new ArrayList<Object>();

Map<String, List<String>> map=new HashMap<String, List<String>>();
Map<String, List<String>> map1=new HashMap<>();
```

Java7提供了“菱形”语法。把两个尖括号并排放在一起非常像一个菱型，这种语法也被称为“菱型”语法。“菱形”语法，它允许调用构造器时在构造器后使用一对尖括号来代表泛  
型信息。但如果程序显式指定了泛型构造器中声明的类型形参的实际类型，则不可以使用“菱形”语法。

```
public static void main(String[] args)
    {
        // MyClass类声明中的E形参是String类型。
        // 泛型构造器中声明的T形参是Integer类型
        MyClass<String> mc1 = new MyClass<>(5);
        // 显式指定泛型构造器中声明的T形参是Integer类型，
        MyClass<String> mc2 = new <Integer> MyClass<String>(5);
        // MyClass类声明中的E形参是String类型。
        // 如果显式指定泛型构造器中声明的T形参是Integer类型
        // 此时就不能使用"菱形"语法，下面代码是错的。
//        MyClass<String> mc3 = new <Integer> MyClass<>(5);
    }
```

**5、泛型接口**

泛型声明。

**6、泛型类**

不存在泛型类。原因：

不管为泛型的类型形参传入哪一种类型实参，对于 Java 来说，它们依然被当成同一个类处理，在  
内存中也只占用一块内存空间，因此在静态方法、静态初始化块或者静态变量的声明和初始化中不允许  
使用类型形参。

由于系统中并不会生成真正泛型类，instanceof运算符后不能使用泛型类。

**7、泛型方法**

**8、类型通配符**

为了表示各种泛型List的父类，可以使用类型通配符，类型通配符是一个问号（？），将一个问号作  
为类型实参传给List集合，写作：List&lt;?&gt; \(意思是元素类型未知的List\)。这个问号（？）被称为通配符，  
它的元素类型可以匹配任何类型。

Java  
泛型提供了**被限制的泛型通配符**。被限制的泛型通配符表示如下：

```
List<? extends Shape> shapes
```

Java泛型不仅允许在使用通配符形参时设定上限，而且可以在**定义类型形参时设定上限**，用于表示传给该类型形参的实际类型要么是该上限类型，要么是该上限类型的子类。

Java 集合框架中的 TreeSet &lt; E &gt;有一个构造器也用到了这种**设定通配符下限**的语法：

// 下面的 E是定义 TreeSet 类时的类型形参

TreeSet\(Comparator&lt;? super E&gt; c\)

TreeSet 会对集合中的元素按自然顺序或定制顺序进行排序。如果需要 TreeSet  
对集合中的所有元素进行定制排序，则要求 TreeSet 对象有一个与之关联的 Comparator 对象。上面构  
造器中的参数 c 就是进行定制排序的 Comparator 对象。

Comparator 接口也是一个带泛型声明的接口：

```
public interface Comparator<T>{
int compare(T fst,Tsed);
}
```

通过这种带下限的通配符的语法，可以在创建 TreeSet 对象时灵活地选择合适的 Comparator 。假定  
需要创建一个 TreeSet &lt; String &gt;集合，并传入一个可以比较 String 大小的 Comparator ,这个 Comparator  
既可以是 Comparator &lt; String &gt;，也可以是 Comparator &lt; Object &gt; ---- 只要尖括号里传入的类型是 String 的  
父类型（或它本身）即可。

9、**类型通配符和泛型方法的区别**

1\)、泛型方法允许类型形参被用来表示方法的一个或多个参数之间的类型依赖关系，或者方法返回值与  
参数之间的类型依赖关系。如果没有这样的类型依赖关系，就不应该使用泛型方法。

2\)、类型通配符既可  
以在方法签名中定义形参的类型，也可以用于定义变量的类型；但泛型方法中的类型形参必须在对应方  
法中显式声明。

** 10、Java 8改进的类型推断    
**

Java 8改进了泛型方法的类型推断能力，类型推断主要有如下两方面。

* 可通过调用方法的上下文来推断类型参数的目标类型。

* 可在方法调用链中，将推断得到的类型参数传递到最后一个方法。

**11、擦除**

当把一个具有泛型信息的对象赋给另一个没有泛型信息的变量时，所有在尖括号之间的类型信息都  
将被扔掉。比如一个Li S t&lt;String&gt;类型被转换为List,则该List对集合元素的类型检查变成了类型参数  
的上限（即Object\)。

