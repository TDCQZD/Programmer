# Java多线程
- 线程创建(三种方式:继承Thread类、实现Runnable接口、使用Callable和Future接口(Java5))
- 线程生命周期(新建（New)、 就绪（Runnable)、运行（Running )、 阻塞（Blocked) 和死亡（Dead))
- 线程操作
    * 线程控制(线程等待：join、线程睡眠：sleep、线程让步：yield、设置线程优先级)
    * 线程同步
        - 同步代码块
        - 同步方法
        - 同步锁(Lock)
    * 线程通信
        - wait()、notify )和 notifyAll()
        - 使用Condition控制线程通信
        - 使用阻塞队列（BlockingQueue）控制线程通信（Java5）
- 线程池


**多线程编程具有如下几个优点：**

- 1、进程之间不能共享内存，但线程之间共享内存非常容易。

- 2、系统创建进程时需要为该进程重新分配系统资源，但创建线程则代价小得多，因此使用多线程来实现多任务并发比多进程的效率高。

- 3、Java 语言内置了多线程功能支持，而不是单纯地作为底层操作系统的调度方式，从而简化了Java的多线程编程。

## 线程创建
### 继承Thread类创建线程类

    * (1)定义Thread类的子类，并重写Thread类的run()方法（线程执行体）。

    * (2)创建Thread子类的实例，即创建线程对象

    * (3)调用线程对象的start()方法来启动该线程。
###  实现Runnable接口创建线程类
    * (1)定义Runnable接口实现类，并重写Runnable接口的run()方法.

    * (2)创建Runnable实现类的实例，并以此实例作为Thread的target来创建Thread对象，该Thread对象是真正的线程对象。

    * (3)调用线程对象的start()方法来启动线程。
###  使用Callable和Future创建线程(Java5以后)

    Java5以后，Java提供Callable接口，该接口提供一个call()方法作为线程执行体，但call()方法比run()方法功能更强大：

    * (1)call()方法可以有返回值

    * (2)call()方法可以声明抛出异常。

    Java5提供Future接口来代表Callable接口里的call()方法的返回值，并为 Future 接口提供了一个FutureTask 实现类，该实现类实现了 Future 接口，并实现了 Runnable 接口——可以作为Thread类的 target。

### 性能分析:
通过继承Thread类或实现Runnable、Callable 接口都可以实现多线程，不过实现 Runnable 接口与实现Callable接口的方式基本相间，只是 Callable 接口里定义的方法有返回值，可以声明抛出异常而已。

## 线程生命周期
当线程被创建并启动以后，它既不是一启动就进入了执行状态，也不是一直处于执行状态，在线程的生命周期中，它要经过新建（New)、 就绪（Runnable)、运行（Running )、 阻塞（Blocked) 和死亡（Dead)5种状态。尤其是当线程启动以后，它不可能一直“霸占”着 CPU 独自运行，所以CPU需要在多条线程之间切换，于是线程状态也会多次在运行、阻塞之间切换。

## 线程操作
### 线程控制
- join线程
    
    join():Thread提供的一个让线程等待另一个线程完成的方法。当某个程序执行流中调用其它线程的join()方法时。调用线程将被阻塞，直到被join()方法加入的join线程执行完为止。

- 线程睡眠：sleep
    
    如果需要让当前正在执行的线程暂停一段时间，并进入阻塞状态，则可以通过调用 Thread 类的静态sleep()方法来实现
- 线程让步：yield

    yield()方法是一个和sleep()方法相似的方法，它也是 Thread 类提供的一个静态方法，它也可以让当前正在执行的线程暂停，但它不会阻塞该线程，它只是将该线程转入就绪状态。 yield()只是让当前线程暂停一下，让系统的线程调度器重新调度一次，完全可能的情况足：当某个线程调用 yield ()方法暂停之后，线程调度器又将其调度出来重新执行。

    实际上，当某个线程调用了  yield ()方法暂停之后，只有优先级与当前线程相同，或存优先级比当前线程更高的处于就绪状态的线程才会获得执行的机会。

- 设置线程优先级
    
    Thread 类提供了setPriority(int newPriority )、 getPriority()方法来设置和返回指定线程的优先级
### 线程同步
- 同步(synchronized)代码块
- 同步(synchronized)方法
- 同步锁(Lock)
### 线程通信
- 传统通信方式，借助于Object类提供的wait()、notify )和 notifyAll()三个方法。
    * wait():导致当前线程等待，直到其他线程调用该同步监视器的notify()方法或notifyAll()方法来唤醒该线程。该wait()方法有三种形式——无时间参数的wait(一直等待，直到其他线程通知）、带毫秒数的wait()和带毫秒、毫微秒参数的wait()(这两种方法都是等待指定时间后自动苏醒)调用wait()方法的当前线程会释放对该同步监视器的锁定。

    * notify():唤解在此同步监视器上等待的单个线程。如果所有线程都在此同步监视器上等待，则会选择唤醒其中一个线程。选择是任意性的。只有当前线程放弃对该同步监视器的锁定后（使用wait()方法)，才可以执行被唤醒的线程。

    * notifyAll()方法:唤醒在此同步监视器上等待的所有线程。只有当前线程放弃对该同步监视器的锁定后，才可以执行被唤醒的线程。
- 使用Condition控制线程通信
- 使用阻塞队列（BlockingQueue）控制线程通信（Java5）
wait()、notify )和 notifyAll()
## 线程池

## FAQ
### 守护线程和非守护线程
在后台运行且为其它的线程提供服务的线程称为后台线程又称守护线程或精灵线程。

> JVM的垃圾回收线程就是典型的后台线程。

> 注：如果所有的前台线程都死亡，后台线程会自动死亡。

守护线程和非守护线程之前的唯一区别在于：是否阻止JVM的正常退出。

JVM正常退出是与异常退出相对的概念:
- 异常退出如调用System.exit(status)退出JVM进程，调用Linux的kill命令杀死进程等。

- JVM正常退出的条件是JVM中所有非守护线程结束任务，即使还有守护线程在运行。

可以通过setDaemon方法设置线程的属性。