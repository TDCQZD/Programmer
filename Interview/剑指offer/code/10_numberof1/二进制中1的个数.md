## 面试题1 0．二进制中1的个数
题目：请实现一个函数，输入一整数，输出该数二进制表示中1的个数。例如把9表示成二进制是1001，有2位是10因此如果输入9，该输出2。

### 分析
**可能引起死循环的解法**
这是一道很基本的考査二进制和位运算的面试题。题目不是很难，我们很快就能形成一个基本的思路：先判断整数二进制表示中最右边一位是不是 1 。接着把输入的整数右移一位，此时原来处于从右边数起的第二位被移到最右边了，再判断是不是 1 。这样每次移动一位，直到整个整数变成0为止。

现在的问题变成怎么判断一个整数的最右边是不是1 了。这很简单，只要把整数和1做位与运算看结果是不是0就知道
了。1除了最右边的一位之外所有位都是0。如果一个整数与1做与运算的
结果是1，表示该整数蜮右边一位是1,否则是0。

面试官看了代码之后可能会问：上面的代码中可以把右移运算换成除以2吗？答案是否定的。因为除法的效率比移位运算要低得多，在实际编程中应尽可能地用移位运算符代替乘除法。

面试官接下来可能要问的第二个问题就是：上面的函数如果输入一个
负数，比如0x80000000,运行的时候会发生什么情况？把负数0x 80000000右移一位的时候并不是简单地把最高位的1移到第二位变成0x 40000000，而是 0xC0000000. 这是因为移位前是个负数仍然要保证移位后足个负数，因此移位后的最高位会设为1。如果一直做右移运算，最终这个数字就会变成 OxFFFFFFFF 而陷入死循环。

**常规解法**

为了避免死循环，可以不右移输入的数字i，首先把i和1做与运算，判断 i 的最低位是不是为1.接着把1左移一位得到2,再和 i 做与运算，就能判断 i 的次低位是不是1……这样反复左移，每次都能判断 i 的其中一位是不是1。

**能给面试官带来惊喜的解法**

在分析这种算法之前，我们先来分析把一个数减去1的情况。如果一个整数不等丁0,那么该整数的二进制表示中至少有一位是1。先假设这个数的最右边一位是1,那么减去1时，最后一位变成0而其他所有位都保持不变。也就是最后一位相当于做了取反操作，由1变成了0。

接下来假设最后一位不是1而是0的情况。如果该整数的二进制表示中最右边1位于第m位，那么减去1时，第m位由1变成0,而第m位之后的所有0都变成1,整数中第m位之前的所有位都保持不变。举个例子：一个二进制数1100,它的第二位是从最右边数起的一个1。减去1后，第二位变成0,它后面的两位0变成1,而前面的1保持不变，因此得到的结果是1011。

在前面两种情况中，我们发现把一个整数减去1，都是把最右边的1变成0。如果它的右边还有0的话，所有的0都变成1,而它左边所有位都保持不变。接下来我们把一个整数和它减去1的结果做位与运算，相当于把它最右边的1变成0。还是以前面的1100为例，它减去1的结果足1011。我们再把1100和1011做位与运算，得到的结果是1000。我们把1100最右边的1变成了0，结果刚好就是1000.

总结：把一个整数减去1，再和原整数做位与运算，会把该整数最右边一个1变为0.那么一个整数的二进制表示中有多少个1，就可以进行多少次这样的操作。
