# 栈实现队列&队列实现栈

## 面试题7：用两个栈实现队列
题目：用两个栈实现一个队列。队列的声明	实现它的两个 appendTail和deleteHead,分别完成在队列尾部插入结点和在队列头部结点的功能。

**分析**

我们通过一个具体的例子来分析往该队列插入和删除元素的过程。首先插入一个元素 a ，不妨先把它插入到 stackl ,此时 stackl 中的元素有{ a },stack 2为空。再压入两个元素 b 和 c ,还是插入到 stackl 中，此时 stackl 中的元素有{ a , b ， c } , 其 中 c 位于栈顶，而 S tack 2仍然是空的（如图2.8 ( a )所示）。

这个时候我们试着从队列中删除一个元素。按照队列先入先出的规则，由于 a 比 b 、 c 先插入到队列中，最先被删除的元素应该是 a 。元素 a 存储在 stackl 中，但并不在栈顶上，因此不能直接进行删除。注意到 stack 2我们还一直没有使用过，现在是让 stack 2发挥作用的时候了。如果我们把stackl 中的元素逐个弹出并压入 stack 2,元素在 stack 2中的顺序正好和原来在 stackl 中的顺序相反。因此经过3次弹出 stackl 和压入 stack 2操作之后，stackl 为空，而 stack 2中的元素是{ c , b , a }，这个时候就可以弹出 stack 2的栈顶 a 了。此时的 stackl 为空，而 stack 2的元素为丨 c , b }，其中 b 在栈顶（如图2.8 ( b )所示)。


如果我们还想继续删除队列的头部应该怎么办呢？剩下的两个元素是 b 和c ， b 比 c 早进入队列，因此 b 应该先删除。而此时 b 恰好又在栈顶上，因此直接弹出stack2的栈顶即可。这次弹出操作之后，stack1中仍然为空，而stack 2为{c}(如图2.8(c)所示).

从上面分析中，总结删除一个元素的步骤：当stack2中不为空时，在stack2中的栈顶元素是最早进入队列的元素，可以弹出。如果stack2为空时，把stack1中元素逐个弹出并压入stack2。由于先进队列的元素被压倒stack1的底端，经过弹出和压入之后就处于stack2的顶端，又可以直接弹出。

接下来再插入一个元素d。我们还是把它压入stackl (如图2.8 (d)所示）,这样会不会有问题呢？我们考虑下一次删除队列的头部stack2不为空，直接弹出它的栈顶元素c (如图2.8 (e)所示)。而C的确是比d先进入队列，应该在d之前从队列中删除，因此不会出现任何矛盾。
![](../../剑指offer/images/2.8.png)



## 面试题扩展：用两个队列实现一个栈

**分析**

我们通过一系列栈的压入和弹出操作来分析用两个队列模拟一个栈的过程。如图2.9 ( a )所示，我们先往栈内压入一个元素 a 。由于两个队列现在都是空的，我们可以选择把 a 插入两个队列的任意一个。我们不妨把a插入 queuel 。接下来继续往栈内压入 b 、 c 两个元素，我们把它们都插入queuel 。这个时候 queuel 包含3个元素 a 、 b 和 c ，其中 a 位于队列的头部，c 位于队列的尾部。

现在我们考虑从栈内弹出一个元素。根据栈的后入先出原则，最后被压入栈的 c 应该最先被弹出。由于 c 位于 queuel 的尾部，而我们每次只能从队列的头部删除元素，因此我们可以先从 queuel 中依次删除元素 a、b并插入到 queue2中，再从 queuel 中删除元素 c 。这就相当于从栈中弹出元
素 c 了（如图2.9 ( b )所示)。我们可以用同样的方法从栈内弹出元素 b (如图2.9 ( c )所示）


接下來我们考虑往找内压入一个元素 d 。此时 queuel 已经有一个元素，我们就把 d 插入到 queuel 的尾部（如图2.9 ( d )所示）。如果我们再从找内弹出一个元索，此时被弹出的应该是最后被压入的 d 。由于 d 位于 queuel的尾部，我们只能先从头删除 queuel 的元素并插入到 queue2,直到在 queuel中遇到 d 再直接把它删除（如图2.9 ( e )所示)。 

![](../../剑指offer/images/2.9.png)