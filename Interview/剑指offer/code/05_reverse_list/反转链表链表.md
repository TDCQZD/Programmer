

## 面试题5：从尾到头打印链表
题目：输入一个链表的头结点，从尾到头反过来打印出每个结点的值。
```
input:1——>2——>3——>null
output:3——>2——>1——>null
```

**思路分析**

1. 使用栈

    思路：遍历链表。遍历的顺序是从头到尾，可输出的顺序是从尾到头。也就是说第一个遍历到的结点最后一个输出，儿最后一个遍历到的结点第一个输出。这就是典型的“后进先出”，使用栈实现这种顺序。每经过一个结点的时候，把该结点放在一个栈中。但遍历整个链表后，再从栈顶开始逐个输出结点的值，此时输出的结点的顺序已经反转过来了。

    缺点：链表非常长的时候，空间复杂度非常过大。

2. 使用递归

    递归本质上就是一个栈结构，于是也可以使用递归实现。要实现反转链表，每访问一个结点的时候，先递归输出它后面的结点，再输出该结点自身即可。

    缺点：链表非常长的时候，空间复杂度非常过大。

3. 使用两个变量——最佳实践

    基于递归实现，当链表非常长的时候，会导致函数调用的层级很深。从而有可能导致函数调用栈溢出。即空间复杂度非常大。

    空间复杂度O(1),只使用变量，不另开内存

   ![反转链表](../../剑指offer/images/list_reserver.png)



## 面试题16：反转链表
题目：定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点。

为了正确地反转一个链表，需要调整链表中指针的方向。为了将调整指针这个复杂的过程分析淸楚，我们可以借助图形来直观地分析。在图3.6(a)所示的链表中，h、i和j是3个相邻的结点。假设经过若干操作，我们已经把结点h之前的指针调整完毕，这些结点的m_pNext都指向前面一个结点。接下来我们把i的m_pNext指向h,此吋的链表结构如图3.6(b)

![](../../剑指offer/images/3.6.png)

不难注意到，由于结点i的m_pNext指向了它的前一个结点，导致我们无法在链表中遍历到结点j.为了避免链表在结点i处断开，我们霈要在调整结点i的m_pNext之前，把结点j保存下来.

也就是说我们在调整结点i的m_pNext指针时，除了需要知道结点i本身之外，还葙要i的前一个结点h,因为我们需要把结点指向节点h.同时，还需要保存i的一个节点j,以防止链表断开。因此相应地我们需要定义3个指针，分别指向当前遍历到的结点、它的前一个结点及后一个结点。

最后我们试着找到反转后链表的头结点。不难分析出反转后链表的头结点是原始链表的尾结点。什么结点是尾结点？自然是 m_ pNext 为NULL的结点。
